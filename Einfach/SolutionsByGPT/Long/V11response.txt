#include <cmath>
#include <cstdint>
#include <fstream>
#include <iostream>
#include <limits>
#include <memory>
#include <vector>

// =========================
// Mathematische Grundlagen
// =========================
struct Vec3 {
    double x, y, z;
    Vec3() : x(0), y(0), z(0) {}
    Vec3(double x_, double y_, double z_) : x(x_), y(y_), z(z_) {}

    Vec3 operator+(const Vec3& b) const { return Vec3(x + b.x, y + b.y, z + b.z); }
    Vec3 operator-(const Vec3& b) const { return Vec3(x - b.x, y - b.y, z - b.z); }
    Vec3 operator*(double s) const { return Vec3(x * s, y * s, z * s); }
    Vec3 operator/(double s) const { return Vec3(x / s, y / s, z / s); }

    Vec3& operator+=(const Vec3& b) {
        x += b.x; y += b.y; z += b.z;
        return *this;
    }
};

inline Vec3 operator*(double s, const Vec3& v) { return v * s; }

inline double dot(const Vec3& a, const Vec3& b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

inline Vec3 normalize(const Vec3& v) {
    double len = std::sqrt(dot(v, v));
    if (len == 0.0) return Vec3();
    return v / len;
}

inline Vec3 reflect(const Vec3& I, const Vec3& N) {
    return I - 2.0 * dot(I, N) * N;
}

inline Vec3 clamp01(const Vec3& c) {
    auto clamp = [](double v) { return v < 0 ? 0 : (v > 1 ? 1 : v); };
    return Vec3(clamp(c.x), clamp(c.y), clamp(c.z));
}

// =========================
// Ray und Materialien
// =========================
struct Ray {
    Vec3 origin;
    Vec3 direction;
};

struct Material {
    Vec3 color;
    double reflection; // 0..1
};

// =========================
// Geometrische Primitiven
// =========================
struct HitInfo {
    double t;
    Vec3 position;
    Vec3 normal;
    const Material* material;
};

class Object {
public:
    virtual ~Object() = default;
    virtual bool intersect(const Ray& ray, double tMin, double tMax, HitInfo& hit) const = 0;
};

class Sphere : public Object {
public:
    Vec3 center;
    double radius;
    Material material;

    Sphere(const Vec3& c, double r, const Material& m)
        : center(c), radius(r), material(m) {}

    bool intersect(const Ray& ray, double tMin, double tMax, HitInfo& hit) const override {
        Vec3 oc = ray.origin - center;
        double a = dot(ray.direction, ray.direction);
        double b = 2.0 * dot(oc, ray.direction);
        double c = dot(oc, oc) - radius * radius;
        double disc = b * b - 4 * a * c;
        if (disc < 0) return false;
        double sqrtD = std::sqrt(disc);

        double t = (-b - sqrtD) / (2.0 * a);
        if (t < tMin || t > tMax) {
            t = (-b + sqrtD) / (2.0 * a);
            if (t < tMin || t > tMax) return false;
        }

        hit.t = t;
        hit.position = ray.origin + ray.direction * t;
        hit.normal = normalize(hit.position - center);
        hit.material = &material;
        return true;
    }
};

class Plane : public Object {
public:
    Vec3 point;
    Vec3 normal;
    Material material;

    Plane(const Vec3& p, const Vec3& n, const Material& m)
        : point(p), normal(normalize(n)), material(m) {}

    bool intersect(const Ray& ray, double tMin, double tMax, HitInfo& hit) const override {
        double denom = dot(normal, ray.direction);
        if (std::fabs(denom) < 1e-6) return false;
        double t = dot(point - ray.origin, normal) / denom;
        if (t < tMin || t > tMax) return false;

        hit.t = t;
        hit.position = ray.origin + ray.direction * t;
        hit.normal = normal;
        hit.material = &material;
        return true;
    }
};

// =========================
// Lichtquelle
// =========================
struct Light {
    Vec3 position;
    Vec3 intensity; // Farbintensit√§t
};

// =========================
// Szene
// =========================
class Scene {
public:
    std::vector<std::unique_ptr<Object>> objects;
    Light light;
};

// =========================
// Raytracing
// =========================
Vec3 trace(const Ray& ray, const Scene& scene, int depth) {
    if (depth <= 0) return Vec3(0, 0, 0);

    HitInfo closestHit;
    closestHit.t = std::numeric_limits<double>::max();
    bool hitAnything = false;

    for (const auto& obj : scene.objects) {
        HitInfo hit;
        if (obj->intersect(ray, 1e-4, closestHit.t, hit)) {
            hitAnything = true;
            closestHit = hit;
        }
    }

    if (!hitAnything) {
        return Vec3(0, 0, 0); // Hintergrund
    }

    // Ambient
    Vec3 color = 0.05 * closestHit.material->color;

    // Schattenpr√ºfung
    Vec3 toLight = scene.light.position - closestHit.position;
    double lightDist = std::sqrt(dot(toLight, toLight));
    Vec3 lightDir = normalize(toLight);

    Ray shadowRay{ closestHit.position + closestHit.normal * 1e-4, lightDir };
    bool inShadow = false;

    for (const auto& obj : scene.objects) {
        HitInfo shadowHit;
        if (obj->intersect(shadowRay, 1e-4, lightDist, shadowHit)) {
            inShadow = true;
            break;
        }
    }

    if (!inShadow) {
        double diff = std::max(0.0, dot(closestHit.normal, lightDir));
        Vec3 diffuse = diff * (closestHit.material->color * scene.light.intensity.x);
        color += diffuse;
    }

    // Reflexion
    if (closestHit.material->reflection > 0.0) {
        Vec3 reflDir = normalize(reflect(ray.direction, closestHit.normal));
        Ray reflRay{ closestHit.position + closestHit.normal * 1e-4, reflDir };
        Vec3 reflColor = trace(reflRay, scene, depth - 1);
        color = (1.0 - closestHit.material->reflection) * color
              + closestHit.material->reflection * reflColor;
    }

    return clamp01(color);
}

// =========================
// Hauptprogramm
// =========================
int main() {
    const int width = 512;
    const int height = 512;

    Scene scene;

    // Materialien
    Material white{ Vec3(0.9, 0.9, 0.9), 0.0 };
    Material red{ Vec3(0.9, 0.2, 0.2), 0.0 };
    Material green{ Vec3(0.2, 0.9, 0.2), 0.0 };
    Material mirror{ Vec3(0.9, 0.9, 0.9), 0.6 };

    // Cornellbox-√§hnliche W√§nde
    scene.objects.push_back(std::make_unique<Plane>(Vec3(0, -1, 0), Vec3(0, 1, 0), white));  // Boden
    scene.objects.push_back(std::make_unique<Plane>(Vec3(0,  1, 0), Vec3(0,-1, 0), white));  // Decke
    scene.objects.push_back(std::make_unique<Plane>(Vec3(0, 0,-3), Vec3(0, 0, 1), white));  // R√ºckwand
    scene.objects.push_back(std::make_unique<Plane>(Vec3(-1,0,0), Vec3(1, 0, 0), red));    // Linke Wand
    scene.objects.push_back(std::make_unique<Plane>(Vec3( 1,0,0), Vec3(-1,0, 0), green));  // Rechte Wand

    // Objekt im Inneren
    scene.objects.push_back(std::make_unique<Sphere>(Vec3(-0.3, -0.5, -1.5), 0.5, mirror));

    // Lichtquelle
    scene.light.position = Vec3(0, 0.9, -1.5);
    scene.light.intensity = Vec3(1, 1, 1);

    // Kamera
    Vec3 camPos(0, 0, 1);
    double fov = 60.0 * M_PI / 180.0;

    std::ofstream out("cornellbox.ppm", std::ios::binary);
    out << "P6\n" << width << " " << height << "\n255\n";

    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            double px = (2.0 * (x + 0.5) / width - 1.0) * std::tan(fov / 2.0) * width / height;
            double py = (1.0 - 2.0 * (y + 0.5) / height) * std::tan(fov / 2.0);

            Ray ray;
            ray.origin = camPos;
            ray.direction = normalize(Vec3(px, py, -1));

            Vec3 col = trace(ray, scene, 3);

            uint8_t r = static_cast<uint8_t>(255 * col.x);
            uint8_t g = static_cast<uint8_t>(255 * col.y);
            uint8_t b = static_cast<uint8_t>(255 * col.z);

            out << r << g << b;
        }
    }

    out.close();
    std::cout << "Bild gespeichert als cornellbox.ppm" << std::endl;
    return 0;
}
Fertig üôÇ
Im Canvas findest du eine **vollst√§ndige, direkt kompilier- und ausf√ºhrbare C++-Implementierung** eines einfachen Raytracers, der eine **Cornellbox-√§hnliche Szene** rendert und als **512 √ó 512 PPM-Bild** speichert.

**Kurz√ºberblick, was erf√ºllt ist:**

* ‚úî Keine externen Bibliotheken, nur C++-Standardbibliothek
* ‚úî Klare Trennung: Vektormathematik, Geometrie, Materialien, Szene, Raytracing
* ‚úî Explizit definierte Primitiven (Planes + Sphere)
* ‚úî Punktlicht **innerhalb** der Box mit **Schattenwurf**
* ‚úî Diffuses Shading + **Spiegelreflexionen**
* ‚úî Statische Kamera, vollst√§ndiger Innenraum sichtbar
* ‚úî Fester Dateiname: `cornellbox.ppm`
* ‚úî Speicherverwaltung √ºber `std::unique_ptr` (RAII, stabil & sauber)

**Kompilieren & Ausf√ºhren (Beispiel):**

```bash
g++ -std=c++17 -O2 raytracer.cpp -o raytracer
./raytracer
```

Das erzeugte `cornellbox.ppm` kannst du mit praktisch jedem Bildbetrachter √∂ffnen (oder z. B. in PNG konvertieren, falls gew√ºnscht ‚Äì **au√üerhalb** des Programms).

Wenn du willst, kann ich dir als N√§chstes z. B.:

* weiche Schatten (Area Light),
* mehrfache Objekte,
* Gamma-Korrektur,
* oder eine strengere Cornell-Box-Geometrie

sauber und modular einbauen.
