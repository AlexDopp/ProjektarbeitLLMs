<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Anki Lern-App – lokal</title>
<style>
body { font-family: Arial, sans-serif; margin:0; background:#f4f6f8; }
header { background:#2c3e50; color:#fff; padding:12px 20px; }
section { background:#fff; margin:16px; padding:16px; border-radius:6px; }
h2 { margin-top:0; }
button, select, input { padding:6px 10px; margin:4px; }
.flex { display:flex; gap:10px; flex-wrap:wrap; }
.card-view {
  border:1px solid #ccc;
  border-radius:6px;
  padding:12px;
  min-height:180px;
  position:relative;
  background:#fafafa;
}
.card-id { position:absolute; top:6px; left:10px; font-size:12px; color:#555; }
.card-date { position:absolute; top:6px; right:10px; font-size:12px; color:#555; }
.card-center { text-align:center; margin-top:50px; font-size:18px; white-space:pre-wrap; }
.hidden { display:none; }
.stat-box { border:1px solid #ccc; border-radius:6px; padding:10px; background:#fafafa; min-width:180px; }
svg { border:1px solid #ccc; background:#fff; }
.legend span { margin-right:12px; font-size:13px; }
.legend i { display:inline-block; width:12px; height:12px; margin-right:4px; }
.timer { font-weight:bold; margin-left:10px; }
</style>
</head>
<body>

<header>
  <h1>Anki Lern- & Fortschritts-App (lokal)</h1>
</header>

<section>
  <h2>1. Deck importieren (JSON)</h2>
  <input type="file" id="importFile" accept=".json">
  <div id="importError" style="color:red;"></div>
</section>

<section>
  <h2>2. Lernziele</h2>
  <input id="goalName" placeholder="Neues Lernziel">
  <button onclick="UI.addGoal()">Hinzufügen</button>
  <div id="goals" class="flex"></div>
</section>

<section>
  <h2>3. Deck-Übersicht</h2>
  <div id="deckStats" class="flex"></div>
</section>

<section>
  <h2>4. Lernsession <span class="timer" id="sessionTimer"></span></h2>
  <div class="flex">
    <select id="sessionGoal"></select>
    <select id="sessionDeck"></select>
    <button onclick="UI.startSession()">Session starten</button>
    <button onclick="UI.stopSession()">Session stoppen</button>
  </div>

  <div id="sessionArea" class="hidden">
    <div class="card-view">
      <div class="card-id" id="cardId"></div>
      <div class="card-date" id="cardDate"></div>
      <div class="card-center" id="cardText"></div>
    </div>
    <button onclick="UI.flipCard()">Umdrehen</button>
    <div>
      <button onclick="UI.rateCard('new')">Neu</button>
      <button onclick="UI.rateCard('hard')">Schwer</button>
      <button onclick="UI.rateCard('easy')">Leicht</button>
      <button onclick="UI.rateCard('learned')">Gelernt</button>
    </div>
  </div>
</section>

<section>
  <h2>5–7. Lernfortschritt & Aktivität (Boxplot)</h2>
  <svg id="boxplot" width="900" height="320"></svg>
  <div class="legend">
    <span><i style="background:#3498db"></i>Neu</span>
    <span><i style="background:#e67e22"></i>Schwer</span>
    <span><i style="background:#2ecc71"></i>Leicht</span>
    <span><i style="background:#9b59b6"></i>Gelernt</span>
  </div>
</section>

<script>
/* ======================
   Datenmodell
====================== */
const Model = {
  state: {
    decks: [],
    goals: [],
    sessions: [],
    currentSession: null
  },
  save() {
    localStorage.setItem("ankiApp", JSON.stringify(this.state));
  },
  load() {
    const d = localStorage.getItem("ankiApp");
    if (d) this.state = JSON.parse(d);
  }
};

/* ======================
   Logik
====================== */
const Logic = {
  MAX_TEXT_LENGTH: 500,
  MAX_LINES: 12,

  shuffle(arr) {
    return arr.map(v => [v, Math.random()])
              .sort((a,b)=>a[1]-b[1])
              .map(v=>v[0]);
  },

  wrapText(text, maxLen) {
    const words = text.split(" ");
    let line="", out="";
    words.forEach(w=>{
      if((line+w).length>maxLen){
        out+=line.trim()+"\n";
        line=w+" ";
      } else line+=w+" ";
    });
    return (out+line).trim();
  },

  validateDeck(json) {
    if (typeof json.deckName !== "string" || !Array.isArray(json.cards)) {
      throw new Error("Deck muss deckName und cards enthalten");
    }
    if (json.cards.length === 0) {
      throw new Error("Leere Decks dürfen nicht importiert werden");
    }

    const idSet = new Set();
    const today = new Date();
    const oneYearMs = 365*24*60*60*1000;

    json.cards.forEach((c,i)=>{
      if (!c.id || !c.front || !c.back || !c.topic) {
        throw new Error("Unvollständige Karte an Position "+i);
      }
      if (idSet.has(c.id)) {
        throw new Error("Doppelte Karten-ID: "+c.id);
      }
      idSet.add(c.id);

      if (c.front.length>this.MAX_TEXT_LENGTH || c.back.length>this.MAX_TEXT_LENGTH) {
        throw new Error("Kartentext zu lang bei ID "+c.id);
      }

      c.front=this.wrapText(c.front,40);
      c.back=this.wrapText(c.back,40);

      if (c.front.split("\n").length>this.MAX_LINES ||
          c.back.split("\n").length>this.MAX_LINES) {
        throw new Error("Zu viele Zeilen bei Karte "+c.id);
      }

      if (c.lastReviewed) {
        const d=new Date(c.lastReviewed);
        if (isNaN(d)) throw new Error("Ungültiges Datum bei "+c.id);
        if (d>today) throw new Error("Datum in Zukunft bei "+c.id);
        if (today-d>oneYearMs) throw new Error("Überfällige Karte >1 Jahr: "+c.id);
      }

      const st=c.status||"new";
      if (!["new","hard","easy","learned"].includes(st)) {
        throw new Error("Ungültiger Status bei "+c.id);
      }
    });
  },

  importDeck(json) {
    this.validateDeck(json);
    json.cards=json.cards.map(c=>({
      id:c.id, front:c.front, back:c.back,
      topic:c.topic, status:c.status||"new",
      lastReviewed:c.lastReviewed||null
    }));
    Model.state.decks.push(json);
    Model.save();
  },

  startSession(goal, deckName) {
    const deck=Model.state.decks.find(d=>d.deckName===deckName);
    if(!deck) return;

    Model.state.currentSession={
      goal, deck:deckName,
      cards:deck.cards,
      order:this.shuffle(deck.cards.map((_,i)=>i)),
      orderIndex:0,
      flipped:false,
      start:Date.now(),
      timer:null
    };
    Model.save();
  },

  nextCardIndex(session){
    if(session.orderIndex>=session.order.length){
      session.order=this.shuffle(session.order);
      session.orderIndex=0;
    }
    return session.order[session.orderIndex++];
  },

  rateCard(status){
    const s=Model.state.currentSession;
    if(!s) return;
    const idx=s.currentCard;
    const card=s.cards[idx];
    card.status=status;
    card.lastReviewed=new Date().toISOString().slice(0,10);
    s.flipped=false;
    Model.save();
  },

  stopSession(){
    const s=Model.state.currentSession;
    if(!s) return;
    clearInterval(s.timer);
    Model.state.sessions.push({
      goal:s.goal,
      deck:s.deck,
      duration:Date.now()-s.start,
      date:new Date().toISOString().slice(0,10)
    });
    Model.state.currentSession=null;
    Model.save();
  }
};

/* ======================
   UI
====================== */
const UI={
  init(){
    Model.load();
    this.renderGoals();
    this.renderDeckStats();
    this.renderSelectors();
    this.renderBoxplot();
  },

  goalTime(name){
    return Model.state.sessions
      .filter(s=>s.goal===name)
      .reduce((a,b)=>a+b.duration,0);
  },

  formatTime(ms){
    const m=Math.floor(ms/60000);
    const s=Math.floor((ms%60000)/1000);
    return `${m}m ${s}s`;
  },

  addGoal(){
    const n=document.getElementById("goalName").value.trim();
    if(!n) return;
    Model.state.goals.push({name:n});
    Model.save();
    this.renderGoals();
    this.renderSelectors();
  },

  renderGoals(){
    const d=document.getElementById("goals");
    d.innerHTML="";
    Model.state.goals.forEach(g=>{
      const b=document.createElement("div");
      b.className="stat-box";
      b.innerHTML=`<strong>${g.name}</strong><br>
        Lernzeit: ${this.formatTime(this.goalTime(g.name))}`;
      d.appendChild(b);
    });
  },

  renderDeckStats(){
    const d=document.getElementById("deckStats");
    d.innerHTML="";
    Model.state.decks.forEach(deck=>{
      const topics={};
      deck.cards.forEach(c=>topics[c.topic]=(topics[c.topic]||0)+1);
      const b=document.createElement("div");
      b.className="stat-box";
      b.innerHTML=`<strong>${deck.deckName}</strong><br>
        Karten: ${deck.cards.length}<br>
        ${Object.entries(topics).map(t=>`${t[0]} (${t[1]})`).join("<br>")}`;
      d.appendChild(b);
    });
  },

  renderSelectors(){
    const g=document.getElementById("sessionGoal");
    const d=document.getElementById("sessionDeck");
    g.innerHTML=""; d.innerHTML="";
    Model.state.goals.forEach(x=>{
      const o=document.createElement("option");
      o.value=x.name; o.textContent=x.name; g.appendChild(o);
    });
    Model.state.decks.forEach(x=>{
      const o=document.createElement("option");
      o.value=x.deckName; o.textContent=x.deckName; d.appendChild(o);
    });
  },

  startSession(){
    const g=document.getElementById("sessionGoal").value;
    const d=document.getElementById("sessionDeck").value;
    Logic.startSession(g,d);
    const s=Model.state.currentSession;
    document.getElementById("sessionArea").classList.remove("hidden");
    s.timer=setInterval(()=>{
      const e=Math.floor((Date.now()-s.start)/1000);
      document.getElementById("sessionTimer").textContent=
        `Zeit: ${Math.floor(e/60)}:${String(e%60).padStart(2,"0")}`;
    },1000);
    this.showNextCard();
  },

  stopSession(){
    Logic.stopSession();
    document.getElementById("sessionArea").classList.add("hidden");
    document.getElementById("sessionTimer").textContent="";
    this.renderGoals();
    this.renderBoxplot();
  },

  showNextCard(){
    const s=Model.state.currentSession;
    if(!s) return;
    s.currentCard=Logic.nextCardIndex(s);
    const c=s.cards[s.currentCard];
    document.getElementById("cardId").textContent=
      `ID: ${c.id} | Thema: ${c.topic} | Status: ${c.status}`;
    document.getElementById("cardDate").textContent=
      c.lastReviewed?`Zuletzt: ${c.lastReviewed}`:"Neu";
    document.getElementById("cardText").textContent=c.front;
  },

  flipCard(){
    const s=Model.state.currentSession;
    if(!s) return;
    const c=s.cards[s.currentCard];
    s.flipped=!s.flipped;
    document.getElementById("cardText").textContent=
      s.flipped?c.back:c.front;
  },

  rateCard(status){
    Logic.rateCard(status);
    this.showNextCard();
  },

  renderBoxplot(){
    const svg=document.getElementById("boxplot");
    svg.innerHTML="";
    const colors={new:"#3498db",hard:"#e67e22",easy:"#2ecc71",learned:"#9b59b6"};
    Model.state.goals.forEach((g,i)=>{
      const stats={new:0,hard:0,easy:0,learned:0};
      Model.state.sessions.filter(s=>s.goal===g.name)
        .forEach(s=>{
          const d=Model.state.decks.find(x=>x.deckName===s.deck);
          if(d) d.cards.forEach(c=>stats[c.status]++);
        });
      let y=280;
      Object.keys(stats).forEach(st=>{
        const h=stats[st]*6;
        const r=document.createElementNS("http://www.w3.org/2000/svg","rect");
        r.setAttribute("x",80+i*140);
        r.setAttribute("y",y-h);
        r.setAttribute("width",60);
        r.setAttribute("height",h);
        r.setAttribute("fill",colors[st]);
        svg.appendChild(r);
        y-=h;
      });
      const t=document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x",80+i*140);
      t.setAttribute("y",300);
      t.textContent=g.name;
      svg.appendChild(t);
    });
  }
};

/* ======================
   Events
====================== */
document.getElementById("importFile").addEventListener("change",e=>{
  const f=e.target.files[0];
  if(!f) return;
  const r=new FileReader();
  r.onload=()=>{
    try{
      const json=JSON.parse(r.result);
      Logic.importDeck(json);
      UI.renderDeckStats();
      UI.renderSelectors();
      document.getElementById("importError").textContent="";
    }catch(err){
      document.getElementById("importError").textContent=err.message;
    }
  };
  r.readAsText(f);
});

UI.init();
</script>
</body>
</html>
