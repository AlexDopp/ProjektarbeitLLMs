<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Anki Lern-App – lokal</title>
<style>
body { font-family: Arial, sans-serif; margin:0; background:#f4f6f8; }
header { background:#2c3e50; color:#fff; padding:12px 20px; }
section { background:#fff; margin:16px; padding:16px; border-radius:6px; }
h2 { margin-top:0; }
button, select, input { padding:6px 10px; margin:4px; }
.flex { display:flex; gap:10px; flex-wrap:wrap; }
.card-view {
  border:1px solid #ccc;
  border-radius:6px;
  padding:12px;
  min-height:180px;
  position:relative;
  background:#fafafa;
}
.card-id { position:absolute; top:6px; left:10px; font-size:12px; color:#555; }
.card-date { position:absolute; top:6px; right:10px; font-size:12px; color:#555; }
.card-center { text-align:center; margin-top:50px; font-size:18px; white-space:pre-wrap; }
.hidden { display:none; }
.stat-box { border:1px solid #ccc; border-radius:6px; padding:10px; background:#fafafa; }
svg { border:1px solid #ccc; background:#fff; }
.legend span { margin-right:12px; font-size:13px; }
.legend i { display:inline-block; width:12px; height:12px; margin-right:4px; }
.timer { font-weight:bold; margin-left:10px; }
</style>
</head>
<body>

<header>
  <h1>Anki Lern- & Fortschritts-App (lokal)</h1>
</header>

<section>
  <h2>1. Deck importieren (JSON)</h2>
  <input type="file" id="importFile" accept=".json">
  <div id="importError" style="color:red;"></div>
</section>

<section>
  <h2>2. Lernziele</h2>
  <input id="goalName" placeholder="Neues Lernziel">
  <button onclick="UI.addGoal()">Hinzufügen</button>
  <div id="goals"></div>
</section>

<section>
  <h2>3. Deck-Übersicht</h2>
  <div id="deckStats" class="flex"></div>
</section>

<section>
  <h2>4. Lernsession <span class="timer" id="sessionTimer"></span></h2>
  <div class="flex">
    <select id="sessionGoal"></select>
    <select id="sessionDeck"></select>
    <button onclick="UI.startSession()">Session starten</button>
    <button onclick="UI.stopSession()">Session stoppen</button>
  </div>

  <div id="sessionArea" class="hidden">
    <div class="card-view">
      <div class="card-id" id="cardId"></div>
      <div class="card-date" id="cardDate"></div>
      <div class="card-center" id="cardText"></div>
    </div>
    <button onclick="UI.flipCard()">Umdrehen</button>
    <div>
      <button onclick="UI.rateCard('new')">Neu</button>
      <button onclick="UI.rateCard('hard')">Schwer</button>
      <button onclick="UI.rateCard('easy')">Leicht</button>
      <button onclick="UI.rateCard('learned')">Gelernt</button>
    </div>
  </div>
</section>

<section>
  <h2>5–7. Lernfortschritt & Aktivität (Boxplot)</h2>
  <svg id="boxplot" width="900" height="320"></svg>
  <div class="legend">
    <span><i style="background:#3498db"></i>Neu</span>
    <span><i style="background:#e67e22"></i>Schwer</span>
    <span><i style="background:#2ecc71"></i>Leicht</span>
    <span><i style="background:#9b59b6"></i>Gelernt</span>
  </div>
</section>

<script>
/* ======================
   Datenmodell
====================== */
const Model = {
  state: {
    decks: [],
    goals: [],
    sessions: [],
    currentSession: null
  },
  save() {
    localStorage.setItem("ankiApp", JSON.stringify(this.state));
  },
  load() {
    const d = localStorage.getItem("ankiApp");
    if (d) this.state = JSON.parse(d);
  }
};

/* ======================
   Logik
====================== */
const Logic = {
  MAX_TEXT_LENGTH: 500,
  MAX_LINES: 12,

  wrapText(text, maxLen) {
    const words = text.split(" ");
    let line = "", result = "";
    words.forEach(w => {
      if ((line + w).length > maxLen) {
        result += line.trim() + "\n";
        line = w + " ";
      } else {
        line += w + " ";
      }
    });
    return (result + line).trim();
  },

  validateDeck(json) {
    if (typeof json.deckName !== "string" || !Array.isArray(json.cards)) {
      throw new Error("Deck muss deckName und cards enthalten");
    }

    const idSet = new Set();
    const today = new Date();
    const oneYearMs = 365 * 24 * 60 * 60 * 1000;

    json.cards.forEach((c, i) => {
      if (!c.id || !c.front || !c.back || !c.topic) {
        throw new Error("Unvollständige Karte an Position " + i);
      }

      if (idSet.has(c.id)) {
        throw new Error("Doppelte Karten-ID gefunden: " + c.id);
      }
      idSet.add(c.id);

      if (c.front.length > this.MAX_TEXT_LENGTH || c.back.length > this.MAX_TEXT_LENGTH) {
        throw new Error("Kartentext zu lang bei ID " + c.id);
      }

      const wrappedFront = this.wrapText(c.front, 40);
      const wrappedBack = this.wrapText(c.back, 40);

      if (wrappedFront.split("\n").length > this.MAX_LINES ||
          wrappedBack.split("\n").length > this.MAX_LINES) {
        throw new Error("Zu viele Zeilen bei Karte " + c.id);
      }

      if (c.lastReviewed) {
        const d = new Date(c.lastReviewed);
        if (isNaN(d.getTime())) {
          throw new Error("Ungültiges Datum bei Karte " + c.id);
        }
        if (d > today) {
          throw new Error("Datum liegt in der Zukunft bei Karte " + c.id);
        }
        if (today - d > oneYearMs) {
          throw new Error("Karte über 1 Jahr überfällig: " + c.id);
        }
      }

      const st = c.status || "new";
      if (!["new","hard","easy","learned"].includes(st)) {
        throw new Error("Ungültiger Kartenstatus bei Karte " + c.id);
      }

      c.front = wrappedFront;
      c.back = wrappedBack;
    });
  },

  importDeck(json) {
    this.validateDeck(json);
    json.cards = json.cards.map(c => ({
      id: c.id,
      front: c.front,
      back: c.back,
      topic: c.topic,
      status: c.status || "new",
      lastReviewed: c.lastReviewed || null
    }));
    Model.state.decks.push(json);
    Model.save();
  },

  startSession(goalName, deckName) {
    const deck = Model.state.decks.find(d => d.deckName === deckName);
    if (!deck) return;

    Model.state.currentSession = {
      goal: goalName,
      deck: deckName,
      cards: deck.cards,
      index: 0,
      flipped: false,
      start: Date.now(),
      timer: null
    };
    Model.save();
  },

  stopSession() {
    const s = Model.state.currentSession;
    if (!s) return;

    Model.state.sessions.push({
      goal: s.goal,
      deck: s.deck,
      duration: Date.now() - s.start,
      date: new Date().toISOString().slice(0,10)
    });

    clearInterval(s.timer);
    Model.state.currentSession = null;
    Model.save();
  },

  rateCard(status) {
    const s = Model.state.currentSession;
    if (!s) return;

    const card = s.cards[s.index];
    card.status = status;
    card.lastReviewed = new Date().toISOString().slice(0,10);

    s.index = (s.index + 1) % s.cards.length;
    s.flipped = false;
    Model.save();
  }
};

/* ======================
   UI
====================== */
const UI = {
  init() {
    Model.load();
    this.renderGoals();
    this.renderDeckStats();
    this.renderSelectors();
    this.renderBoxplot();
  },

  addGoal() {
    const name = document.getElementById("goalName").value.trim();
    if (!name) return;
    Model.state.goals.push({ name });
    Model.save();
    this.renderGoals();
    this.renderSelectors();
  },

  renderGoals() {
    const div = document.getElementById("goals");
    div.innerHTML = "";
    Model.state.goals.forEach(g => {
      const b = document.createElement("div");
      b.className = "stat-box";
      b.textContent = g.name;
      div.appendChild(b);
    });
  },

  renderDeckStats() {
    const div = document.getElementById("deckStats");
    div.innerHTML = "";
    Model.state.decks.forEach(d => {
      const topics = {};
      d.cards.forEach(c => topics[c.topic] = (topics[c.topic]||0)+1);
      const box = document.createElement("div");
      box.className = "stat-box";
      box.innerHTML = `<strong>${d.deckName}</strong><br>
        Karten: ${d.cards.length}<br>
        ${Object.entries(topics).map(t=>`${t[0]} (${t[1]})`).join("<br>")}`;
      div.appendChild(box);
    });
  },

  renderSelectors() {
    const goalSel = document.getElementById("sessionGoal");
    const deckSel = document.getElementById("sessionDeck");
    goalSel.innerHTML = "";
    deckSel.innerHTML = "";
    Model.state.goals.forEach(g => {
      const o = document.createElement("option");
      o.value = g.name; o.textContent = g.name;
      goalSel.appendChild(o);
    });
    Model.state.decks.forEach(d => {
      const o = document.createElement("option");
      o.value = d.deckName; o.textContent = d.deckName;
      deckSel.appendChild(o);
    });
  },

  startSession() {
    const g = document.getElementById("sessionGoal").value;
    const d = document.getElementById("sessionDeck").value;
    Logic.startSession(g, d);
    document.getElementById("sessionArea").classList.remove("hidden");

    const s = Model.state.currentSession;
    s.timer = setInterval(() => {
      const elapsed = Math.floor((Date.now() - s.start) / 1000);
      document.getElementById("sessionTimer").textContent =
        `Zeit: ${Math.floor(elapsed/60)}:${String(elapsed%60).padStart(2,"0")}`;
    }, 1000);

    this.showCard();
  },

  stopSession() {
    Logic.stopSession();
    document.getElementById("sessionArea").classList.add("hidden");
    document.getElementById("sessionTimer").textContent = "";
    this.renderBoxplot();
  },

  showCard() {
    const s = Model.state.currentSession;
    if (!s) return;
    const c = s.cards[s.index];
    document.getElementById("cardId").textContent =
      `ID: ${c.id} | Thema: ${c.topic} | Status: ${c.status}`;
    document.getElementById("cardDate").textContent =
      c.lastReviewed ? "Zuletzt: " + c.lastReviewed : "Neu";
    document.getElementById("cardText").textContent =
      s.flipped ? c.back : c.front;
  },

  flipCard() {
    const s = Model.state.currentSession;
    if (!s) return;
    s.flipped = !s.flipped;
    this.showCard();
  },

  rateCard(status) {
    Logic.rateCard(status);
    this.showCard();
  },

  renderBoxplot() {
    const svg = document.getElementById("boxplot");
    svg.innerHTML = "";
    const colors = {new:"#3498db",hard:"#e67e22",easy:"#2ecc71",learned:"#9b59b6"};
    const goals = Model.state.goals.map(g => g.name);

    goals.forEach((goal, i) => {
      const relatedSessions = Model.state.sessions.filter(s => s.goal === goal);
      if (!relatedSessions.length) return;

      const stats = {new:0,hard:0,easy:0,learned:0};
      relatedSessions.forEach(s => {
        const deck = Model.state.decks.find(d => d.deckName === s.deck);
        if (!deck) return;
        deck.cards.forEach(c => stats[c.status]++);
      });

      let y = 280;
      Object.keys(stats).forEach(st => {
        const h = stats[st] * 6;
        const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
        r.setAttribute("x", 80 + i*140);
        r.setAttribute("y", y - h);
        r.setAttribute("width", 60);
        r.setAttribute("height", h);
        r.setAttribute("fill", colors[st]);
        svg.appendChild(r);
        y -= h;
      });

      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x", 80 + i*140);
      t.setAttribute("y", 300);
      t.textContent = goal;
      svg.appendChild(t);
    });
  }
};

/* ======================
   Events
====================== */
document.getElementById("importFile").addEventListener("change", e => {
  const f = e.target.files[0];
  if (!f) return;
  const r = new FileReader();
  r.onload = () => {
    try {
      const json = JSON.parse(r.result);
      Logic.importDeck(json);
      UI.renderDeckStats();
      UI.renderSelectors();
      document.getElementById("importError").textContent = "";
    } catch(err) {
      document.getElementById("importError").textContent = err.message;
    }
  };
  r.readAsText(f);
});

UI.init();
</script>
</body>
</html>
